# Utoipa - Getting Started

**Pages:** 9

---

## Module security Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/security/index.html

**Contents:**
- Module security Copy item path
- Structs§
- Enums§

Implements OpenAPI Security Schema types.

Refer to SecurityScheme for usage and more details.

---

## Module security Copy item path

**URL:** https://docs.rs/utoipa/5.4.0/utoipa/openapi/security/index.html

**Contents:**
- Module security Copy item path
- Structs§
- Enums§

Implements OpenAPI Security Schema types.

Refer to SecurityScheme for usage and more details.

---

## Module schema Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/schema/index.html

**Contents:**
- Module schema Copy item path
- Structs§
- Enums§
- Traits§
- Functions§

Implements OpenAPI Schema Object types which can be used to define field properties, enum values, array or object types.

---

## Crate utoipa Copy item path

**URL:** https://docs.rs/utoipa/5.4.0/utoipa/index.html

**Contents:**
- Crate utoipa Copy item path
- §Choose your flavor and document your API with ice cold IPA
  - §Features
- §What’s up with the word play?
- §Crate Features
    - §Default Library Support
- §Install
- §Examples
- §Modify OpenAPI at runtime
- §Go beyond the surface

Want to have your API documented with OpenAPI? But you don’t want to see the trouble with manual yaml or json tweaking? Would like it to be so easy that it would almost be like utopic? Don’t worry utoipa is just there to fill this gap. It aims to do if not all then the most of heavy lifting for you enabling you to focus writing the actual API logic instead of documentation. It aims to be minimal, simple and fast. It uses simple proc macros which you can use to annotate your code to have items documented.

Utoipa crate provides autogenerated OpenAPI documentation for Rust REST APIs. It treats code first approach as a first class citizen and simplifies API documentation by providing simple macros for generating the documentation from your code.

It also contains Rust types of OpenAPI spec allowing you to write the OpenAPI spec only using Rust if auto-generation is not your flavor or does not fit your purpose.

Long term goal of the library is to be the place to go when OpenAPI documentation is needed in Rust codebase.

Utoipa is framework agnostic and could be used together with any web framework or even without one. While being portable and standalone one of it’s key aspects is simple integration with web frameworks.

Currently utoipa provides simple integration with actix-web framework but is not limited to the actix-web framework. All functionalities are not restricted to any specific framework.

Others* = For example warp but could be anything.

Refer to the existing examples to find out more.

The name comes from words utopic and api where uto is the first three letters of utopic and the ipa is api reversed. Aaand… ipa is also awesome type of beer.

Add dependency declaration to Cargo.toml.

Create type with ToSchema and use it in #[utoipa::path(...)] that is registered to the OpenApi.

You can modify generated OpenAPI at runtime either via generated types directly or using Modify trait.

Modify generated OpenAPI via types directly.

You can even convert the generated OpenApi to openapi::OpenApiBuilder.

See Modify trait for examples on how to modify generated OpenAPI via it.

**Examples:**

Example 1 (json):
```json
[dependencies]
utoipa = "5"
```

Example 2 (rust):
```rust
use utoipa::{OpenApi, ToSchema};

#[derive(ToSchema)]
struct Pet {
   id: u64,
   name: String,
   age: Option<i32>,
}

/// Get pet by id
///
/// Get pet from database by pet id
#[utoipa::path(
    get,
    path = "/pets/{id}",
    responses(
        (status = 200, description = "Pet found successfully", body = Pet),
        (status = NOT_FOUND, description = "Pet was not found")
    ),
    params(
        ("id" = u64, Path, description = "Pet database id to get Pet for"),
    )
)]
async fn get_pet_by_id(pet_id: u64) -> Result<Pet, NotFound> {
    Ok(Pet {
        id: pet_id,
        age: None,
        name: "lightning".to_string(),
    })
}

#[derive(OpenApi)]
#[openapi(paths(get_pet_by_id))]
struct ApiDoc;

println!("{}", ApiDoc::openapi().to_pretty_json().unwrap());
```

Example 3 (rust):
```rust
use utoipa::{OpenApi, ToSchema};

#[derive(ToSchema)]
struct Pet {
   id: u64,
   name: String,
   age: Option<i32>,
}

/// Get pet by id
///
/// Get pet from database by pet id
#[utoipa::path(
    get,
    path = "/pets/{id}",
    responses(
        (status = 200, description = "Pet found successfully", body = Pet),
        (status = NOT_FOUND, description = "Pet was not found")
    ),
    params(
        ("id" = u64, Path, description = "Pet database id to get Pet for"),
    )
)]
async fn get_pet_by_id(pet_id: u64) -> Result<Pet, NotFound> {
    Ok(Pet {
        id: pet_id,
        age: None,
        name: "lightning".to_string(),
    })
}

#[derive(OpenApi)]
#[openapi(paths(get_pet_by_id))]
struct ApiDoc;

println!("{}", ApiDoc::openapi().to_pretty_json().unwrap());
```

Example 4 (julia):
```julia
#[derive(OpenApi)]
#[openapi(
    info(description = "My Api description"),
)]
struct ApiDoc;

let mut doc = ApiDoc::openapi();
doc.info.title = String::from("My Api");
```

---

## Module example Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/example/index.html

**Contents:**
- Module example Copy item path
- Structs§

Implements OpenAPI Example Object can be used to define examples for Responses and RequestBodys.

---

## Crate utoipa Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/index.html

**Contents:**
- Crate utoipa Copy item path
- §Choose your flavor and document your API with ice cold IPA
  - §Features
- §What’s up with the word play?
- §Crate Features
    - §Default Library Support
- §Install
- §Examples
- §Modify OpenAPI at runtime
- §Go beyond the surface

Want to have your API documented with OpenAPI? But you don’t want to see the trouble with manual yaml or json tweaking? Would like it to be so easy that it would almost be like utopic? Don’t worry utoipa is just there to fill this gap. It aims to do if not all then the most of heavy lifting for you enabling you to focus writing the actual API logic instead of documentation. It aims to be minimal, simple and fast. It uses simple proc macros which you can use to annotate your code to have items documented.

Utoipa crate provides autogenerated OpenAPI documentation for Rust REST APIs. It treats code first approach as a first class citizen and simplifies API documentation by providing simple macros for generating the documentation from your code.

It also contains Rust types of OpenAPI spec allowing you to write the OpenAPI spec only using Rust if auto-generation is not your flavor or does not fit your purpose.

Long term goal of the library is to be the place to go when OpenAPI documentation is needed in Rust codebase.

Utoipa is framework agnostic and could be used together with any web framework or even without one. While being portable and standalone one of it’s key aspects is simple integration with web frameworks.

Currently utoipa provides simple integration with actix-web framework but is not limited to the actix-web framework. All functionalities are not restricted to any specific framework.

Others* = For example warp but could be anything.

Refer to the existing examples to find out more.

The name comes from words utopic and api where uto is the first three letters of utopic and the ipa is api reversed. Aaand… ipa is also awesome type of beer.

Add dependency declaration to Cargo.toml.

Create type with ToSchema and use it in #[utoipa::path(...)] that is registered to the OpenApi.

You can modify generated OpenAPI at runtime either via generated types directly or using Modify trait.

Modify generated OpenAPI via types directly.

You can even convert the generated OpenApi to openapi::OpenApiBuilder.

See Modify trait for examples on how to modify generated OpenAPI via it.

**Examples:**

Example 1 (json):
```json
[dependencies]
utoipa = "5"
```

Example 2 (rust):
```rust
use utoipa::{OpenApi, ToSchema};

#[derive(ToSchema)]
struct Pet {
   id: u64,
   name: String,
   age: Option<i32>,
}

/// Get pet by id
///
/// Get pet from database by pet id
#[utoipa::path(
    get,
    path = "/pets/{id}",
    responses(
        (status = 200, description = "Pet found successfully", body = Pet),
        (status = NOT_FOUND, description = "Pet was not found")
    ),
    params(
        ("id" = u64, Path, description = "Pet database id to get Pet for"),
    )
)]
async fn get_pet_by_id(pet_id: u64) -> Result<Pet, NotFound> {
    Ok(Pet {
        id: pet_id,
        age: None,
        name: "lightning".to_string(),
    })
}

#[derive(OpenApi)]
#[openapi(paths(get_pet_by_id))]
struct ApiDoc;

println!("{}", ApiDoc::openapi().to_pretty_json().unwrap());
```

Example 3 (rust):
```rust
use utoipa::{OpenApi, ToSchema};

#[derive(ToSchema)]
struct Pet {
   id: u64,
   name: String,
   age: Option<i32>,
}

/// Get pet by id
///
/// Get pet from database by pet id
#[utoipa::path(
    get,
    path = "/pets/{id}",
    responses(
        (status = 200, description = "Pet found successfully", body = Pet),
        (status = NOT_FOUND, description = "Pet was not found")
    ),
    params(
        ("id" = u64, Path, description = "Pet database id to get Pet for"),
    )
)]
async fn get_pet_by_id(pet_id: u64) -> Result<Pet, NotFound> {
    Ok(Pet {
        id: pet_id,
        age: None,
        name: "lightning".to_string(),
    })
}

#[derive(OpenApi)]
#[openapi(paths(get_pet_by_id))]
struct ApiDoc;

println!("{}", ApiDoc::openapi().to_pretty_json().unwrap());
```

Example 4 (julia):
```julia
#[derive(OpenApi)]
#[openapi(
    info(description = "My Api description"),
)]
struct ApiDoc;

let mut doc = ApiDoc::openapi();
doc.info.title = String::from("My Api");
```

---

## Module server Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/server/index.html

**Contents:**
- Module server Copy item path
- §Examples
- Structs§

Implements OpenAPI Server Object types to configure target servers.

OpenAPI will implicitly add Server with url = "/" to OpenApi when no servers are defined.

Server can be used to alter connection url for path operations. It can be a relative path e.g /api/v1 or valid http url e.g. http://alternative.api.com/api/v1.

Relative path will append to the sever address so the connection url for path operations will become server address + relative path.

Optionally it also supports parameter substitution with {variable} syntax.

See Modify trait for details how add servers to OpenApi.

Create new server with relative path.

Create server with custom url using a builder.

Create server with builder and variable substitution.

**Examples:**

Example 1 (yaml):
```yaml
Server::new("/api/v1");
```

Example 2 (rust):
```rust
Server::new("/api/v1");
```

Example 3 (yaml):
```yaml
ServerBuilder::new().url("https://alternative.api.url.test/api").build();
```

Example 4 (rust):
```rust
ServerBuilder::new().url("https://alternative.api.url.test/api").build();
```

---

## Module content Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/content/index.html

**Contents:**
- Module content Copy item path
- Structs§

Implements content object for request body and response.

---

## Module info Copy item path

**URL:** https://docs.rs/utoipa/latest/utoipa/openapi/info/index.html

**Contents:**
- Module info Copy item path
- Structs§

Implements OpenAPI Metadata types.

Refer to OpenApi trait and derive documentation for examples and usage details.

---
